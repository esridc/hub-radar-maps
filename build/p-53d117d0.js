import{aM as t,dP as e,fq as n,fr as i,fs as r,ft as s,an as o,ao as a,fu as l,b$ as u,fv as c,cB as f,bt as h,dr as p,ap as y,dG as d,fw as m,dc as w,fx as g,fy as v,co as b,fz as x,U as j,dA as M,fA as P,am as N,di as F,ec as O,a as V,cH as A,dK as G,aY as S,fB as E,e5 as $,b4 as R,h as U,fC as z,W as B,fD as I,fE as T}from"./p-3013819f.js";import{n as H,p as _}from"./p-c779faaf.js";function q(t,e){return e?"xoffset"in e&&e.xoffset?Math.max(t,Math.abs(e.xoffset)):"yoffset"in e&&e.yoffset?Math.max(t,Math.abs(e.yoffset||0)):t:t}function D(t){let e=0,n=0;for(let i=0;i<t.length;i++){const r=t[i].size;"number"==typeof r&&(e+=r,n++)}return e/n}function k(t,e){return"number"==typeof t?t:t?.stops?.length?D(t.stops):e}function J(t,e){if(!e)return t;const n=e.filter((t=>"size"===t.type)).map((e=>{const{maxSize:n,minSize:i}=e;return(k(n,t)+k(i,t))/2}));let i=0;const r=n.length;if(0===r)return t;for(let t=0;t<r;t++)i+=n[t];const s=Math.floor(i/r);return Math.max(s,t)}function L(t){const e=t?.renderer,n=t?.pointerType,i="touch"===n?9:6;if(!e)return i;const r="visualVariables"in e?J(i,e.visualVariables):i;if("simple"===e.type)return q(r,e.symbol);if("unique-value"===e.type){let t=r;return e.uniqueValueInfos?.forEach((e=>{t=q(t,e.symbol)})),t}if("class-breaks"===e.type){let t=r;return e.classBreakInfos.forEach((e=>{t=q(t,e.symbol)})),t}return r}function Z(n,i){const{dpi:r,gdbVersion:s,geometry:o,geometryPrecision:a,height:l,historicMoment:u,layerOption:c,mapExtent:f,maxAllowableOffset:h,returnFieldName:p,returnGeometry:y,returnUnformattedValues:d,returnZ:m,spatialReference:w,timeExtent:g,tolerance:v,width:b}=n.toJSON(),{dynamicLayers:x,layerDefs:j,layerIds:M}=Q(n),P=null!=i?.geometry?i.geometry:null,N={historicMoment:u,geometryPrecision:a,maxAllowableOffset:h,returnFieldName:p,returnGeometry:y,returnUnformattedValues:d,returnZ:m,tolerance:v},F=P&&P.toJSON()||o;N.imageDisplay=`${b},${l},${r}`,s&&(N.gdbVersion=s),F&&(delete F.spatialReference,N.geometry=JSON.stringify(F),N.geometryType=t(F));const O=w??F?.spatialReference??f?.spatialReference;if(O&&(N.sr=e(O)),N.time=g?[g.start,g.end].join(","):null,f){const{xmin:t,ymin:e,xmax:n,ymax:i}=f;N.mapExtent=`${t},${e},${n},${i}`}return j&&(N.layerDefs=j),x&&!j&&(N.dynamicLayers=x),N.layers="popup"===c?"visible":c,M&&!x&&(N.layers+=`:${M.join(",")}`),N}function Q(t){const{mapExtent:e,floors:s,width:o,sublayers:a,layerIds:l,layerOption:u,gdbVersion:c}=t,f=a?.find((t=>null!=t.layer))?.layer?.serviceSublayers,h="popup"===u,p={},y=n({extent:e,width:o,spatialReference:e?.spatialReference}),d=[],m=t=>{const e=0===y,n=0===t.minScale||y<=t.minScale,i=0===t.maxScale||y>=t.maxScale;if(t.visible&&(e||n&&i))if(t.sublayers)t.sublayers.forEach(m);else{if(!1===l?.includes(t.id)||h&&(!t.popupTemplate||!t.popupEnabled))return;d.unshift(t)}};if(a?.forEach(m),a&&!d.length)p.layerIds=[];else{const t=i(d,f,c),e=d.map((t=>{const e=r(s,t);return t.toExportImageJSON(e)}));if(t)p.dynamicLayers=JSON.stringify(e);else{if(a){let t=d.map((({id:t})=>t));l&&(t=t.filter((t=>l.includes(t)))),p.layerIds=t}else l?.length&&(p.layerIds=l);const t=W(s,d);if(null!=t&&t.length){const e={};for(const n of t)n.definitionExpression&&(e[n.id]=n.definitionExpression);Object.keys(e).length&&(p.layerDefs=JSON.stringify(e))}}}return p}function W(t,e){const n=!!t?.length,i=e.filter((t=>null!=t.definitionExpression||n&&null!=t.floorInfo));return i.length?i.map((e=>{const n=r(t,e),i=s(n,e.definitionExpression);return{id:e.id,definitionExpression:i??void 0}})):null}var C;let K=C=class extends d{static from(t){return m(C,t)}constructor(t){super(t),this.dpi=96,this.floors=null,this.gdbVersion=null,this.geometry=null,this.geometryPrecision=null,this.height=400,this.historicMoment=null,this.layerIds=null,this.layerOption="top",this.mapExtent=null,this.maxAllowableOffset=null,this.returnFieldName=!0,this.returnGeometry=!1,this.returnM=!1,this.returnUnformattedValues=!0,this.returnZ=!1,this.spatialReference=null,this.sublayers=null,this.timeExtent=null,this.tolerance=null,this.width=400}writeHistoricMoment(t,e){e.historicMoment=t&&t.getTime()}};o([a({type:Number,json:{write:!0}})],K.prototype,"dpi",void 0),o([a()],K.prototype,"floors",void 0),o([a({type:String,json:{write:!0}})],K.prototype,"gdbVersion",void 0),o([a({types:l,json:{read:u,write:!0}})],K.prototype,"geometry",void 0),o([a({type:Number,json:{write:!0}})],K.prototype,"geometryPrecision",void 0),o([a({type:Number,json:{write:!0}})],K.prototype,"height",void 0),o([a({type:Date})],K.prototype,"historicMoment",void 0),o([c("historicMoment")],K.prototype,"writeHistoricMoment",null),o([a({type:[Number],json:{write:!0}})],K.prototype,"layerIds",void 0),o([a({type:["top","visible","all","popup"],json:{write:!0}})],K.prototype,"layerOption",void 0),o([a({type:f,json:{write:!0}})],K.prototype,"mapExtent",void 0),o([a({type:Number,json:{write:!0}})],K.prototype,"maxAllowableOffset",void 0),o([a({type:Boolean,json:{write:!0}})],K.prototype,"returnFieldName",void 0),o([a({type:Boolean,json:{write:!0}})],K.prototype,"returnGeometry",void 0),o([a({type:Boolean,json:{write:!0}})],K.prototype,"returnM",void 0),o([a({type:Boolean,json:{write:!0}})],K.prototype,"returnUnformattedValues",void 0),o([a({type:Boolean,json:{write:!0}})],K.prototype,"returnZ",void 0),o([a({type:h,json:{write:!0}})],K.prototype,"spatialReference",void 0),o([a()],K.prototype,"sublayers",void 0),o([a({type:p,json:{write:!0}})],K.prototype,"timeExtent",void 0),o([a({type:Number,json:{write:!0}})],K.prototype,"tolerance",void 0),o([a({type:Number,json:{write:!0}})],K.prototype,"width",void 0),K=C=o([y("esri.rest.support.IdentifyParameters")],K);const Y=K;let X=class extends d{constructor(t){super(t),this.displayFieldName=null,this.feature=null,this.layerId=null,this.layerName=null}readFeature(t,e){return w.fromJSON({attributes:{...e.attributes},geometry:{...e.geometry}})}writeFeature(t,e){if(!t)return;const{attributes:n,geometry:i}=t;n&&(e.attributes={...n}),null!=i&&(e.geometry=i.toJSON(),e.geometryType=v.toJSON(i.type))}};o([a({type:String,json:{write:!0}})],X.prototype,"displayFieldName",void 0),o([a({type:w})],X.prototype,"feature",void 0),o([g("feature",["attributes","geometry"])],X.prototype,"readFeature",null),o([c("feature")],X.prototype,"writeFeature",null),o([a({type:Number,json:{write:!0}})],X.prototype,"layerId",void 0),o([a({type:String,json:{write:!0}})],X.prototype,"layerName",void 0),X=o([y("esri.rest.support.IdentifyResult")],X);const tt=X;async function et(t,e,n){const i=(e=it(e)).geometry?[e.geometry]:[],r=M(t);return r.path+="/identify",b(i).then((t=>{const i=Z(e,{geometry:t?.[0]}),s=x({...r.query,f:"json",...i}),o=P(s,n);return j(r.path,o).then(nt).then((t=>rt(t,e.sublayers)))}))}function nt(t){const e=t.data;return e.results=e.results||[],e.exceededTransferLimit=Boolean(e.exceededTransferLimit),e.results=e.results.map((t=>tt.fromJSON(t))),e}function it(t){return t=Y.from(t)}function rt(t,e){if(!e?.length)return t;const n=new Map;function i(t){n.set(t.id,t),t.sublayers&&t.sublayers.forEach(i)}e.forEach(i);for(const e of t.results)e.feature.sourceLayer=n.get(e.layerId);return t}let st=null;function ot(t,e){return"tile"===e.type||"map-image"===e.type}let at=class extends N{constructor(t){super(t),this._featuresResolutions=new WeakMap,this.highlightGraphics=null,this.highlightGraphicUpdated=null,this.updateHighlightedFeatures=F((async t=>{this.destroyed||this.updatingHandles.addPromise(this._updateHighlightedFeaturesGeometries(t).catch((()=>{})))}))}initialize(){const t=t=>{this.updatingHandles.addPromise(this._updateHighlightedFeaturesSymbols(t).catch((()=>{}))),this.updateHighlightedFeatures(this._highlightGeometriesResolution)};this.addHandles([O((()=>this.highlightGraphics),"change",(e=>t(e.added)),{onListenerAdd:e=>t(e)})])}async fetchPopupFeaturesAtLocation(t,e){const{layerView:{layer:n,view:{scale:i}}}=this;if(!t)throw new V("fetchPopupFeatures:invalid-area","Nothing to fetch without area",{layer:n});const r=lt(n.sublayers,i,e);if(!r.length)return[];const s=await ct(n,r);if(!((n.capabilities?.operations?.supportsIdentify??!0)&&n.version>=10.5)&&!s)throw new V("fetchPopupFeatures:not-supported","query operation is disabled for this service",{layer:n});return s?this._fetchPopupFeaturesUsingQueries(t,r,e):this._fetchPopupFeaturesUsingIdentify(t,r,e)}clearHighlights(){this.highlightGraphics?.removeAll()}highlight(t){const e=this.highlightGraphics;if(!e)return A();let n=null;if(t instanceof w?n=[t]:G.isCollection(t)&&t.length>0?n=t.toArray():Array.isArray(t)&&t.length>0&&(n=t),n=n?.filter(S),!n?.length)return A();for(const t of n){const e=t.sourceLayer;null!=e&&"geometryType"in e&&"point"===e.geometryType&&(t.visible=!1)}return e.addMany(n),A((()=>e.removeMany(n??[])))}async _updateHighlightedFeaturesSymbols(t){const{layerView:{view:e},highlightGraphics:n,highlightGraphicUpdated:i}=this;if(n&&i)for(const r of t){const t=r.sourceLayer&&"renderer"in r.sourceLayer&&r.sourceLayer.renderer;r.sourceLayer&&"geometryType"in r.sourceLayer&&"point"===r.sourceLayer.geometryType&&t&&"getSymbolAsync"in t&&t.getSymbolAsync(r).then((async s=>{s||=new E;let o=null;const a="visualVariables"in t?t.visualVariables?.find((t=>"size"===t.type)):void 0;a&&(st||(st=(await import("./p-3013819f.js").then((function(t){return t.o4}))).getSize),o=st(a,r,{view:e.type,scale:e.scale,shape:"simple-marker"===s.type?s.style:null})),o||="width"in s&&"height"in s&&null!=s.width&&null!=s.height?Math.max(s.width,s.height):"size"in s?s.size:16,n.includes(r)&&(r.symbol=new E({style:"square",size:o,xoffset:"xoffset"in s?s.xoffset:0,yoffset:"yoffset"in s?s.yoffset:0}),i(r,"symbol"),r.visible=!0)}))}}async _updateHighlightedFeaturesGeometries(t){const{layerView:{layer:e,view:n},highlightGraphics:i,highlightGraphicUpdated:r}=this;if(this._highlightGeometriesResolution=t,!r||!i?.length||!e.capabilities.operations.supportsQuery)return;const s=this._getTargetResolution(t),o=new Map;for(const t of i)if(!this._featuresResolutions.has(t)||this._featuresResolutions.get(t)>s){const e=t.sourceLayer;$(o,e,(()=>new Map)).set(t.getObjectId(),t)}const a=Array.from(o,(([t,e])=>{const i=t.createQuery();return i.objectIds=[...e.keys()],i.outFields=[t.objectIdField],i.returnGeometry=!0,i.maxAllowableOffset=s,i.outSpatialReference=n.spatialReference,t.queryFeatures(i)})),l=await Promise.all(a);if(!this.destroyed)for(const{features:t}of l)for(const e of t){const t=e.sourceLayer,n=o.get(t).get(e.getObjectId());n&&i.includes(n)&&(n.geometry=e.geometry,r(n,"geometry"),this._featuresResolutions.set(n,s))}}_getTargetResolution(t){const e=t*R(this.layerView.view.spatialReference),n=e/16;return n<=10?0:t/e*n}async _fetchPopupFeaturesUsingIdentify(t,e,n){const i=await this._createIdentifyParameters(t,e,n);if(null==i)return[];const{results:r}=await et(this.layerView.layer.parsedUrl,i,n);return r.map((t=>t.feature))}async _createIdentifyParameters(t,e,n){const{floors:i,layer:r,timeExtent:s,view:{spatialReference:o,scale:a}}=this.layerView;if(!e.length)return null;await Promise.all(e.map((({sublayer:t})=>t.load(n).catch((()=>{})))));const l=Math.min(U("mapservice-popup-identify-max-tolerance"),r.allSublayers.reduce(((t,e)=>e.renderer?L({renderer:e.renderer,pointerType:n?.pointerType}):t),2)),u=this.createFetchPopupFeaturesQueryGeometry(t,l),c=z(a,o),h=Math.round(u.width/c),p=new f({xmin:u.center.x-c*h,ymin:u.center.y-c*h,xmax:u.center.x+c*h,ymax:u.center.y+c*h,spatialReference:u.spatialReference});return new Y({floors:i,gdbVersion:"gdbVersion"in r?r.gdbVersion:void 0,geometry:t,height:h,layerOption:"popup",mapExtent:p,returnGeometry:!0,spatialReference:o,sublayers:r.sublayers,timeExtent:s,tolerance:l,width:h})}async _fetchPopupFeaturesUsingQueries(t,e,n){const{layerView:{floors:i,timeExtent:s}}=this,o=e.map((async({sublayer:e,popupTemplate:o})=>{if(await e.load(n).catch((()=>{})),e.capabilities&&!e.capabilities.operations.supportsQuery)return[];const a=e.createQuery(),l=L({renderer:e.renderer,pointerType:n?.pointerType}),u=this.createFetchPopupFeaturesQueryGeometry(t,l),c=new Set,[f]=await Promise.all([H(e,o),e.renderer?.collectRequiredFields(c,e.fieldsIndex)]);B(n),I(c,e.fieldsIndex,f);const h=Array.from(c).sort();if(a.geometry=u,a.outFields=h,a.timeExtent=s,i){const t=i.clone(),n=r(t,e);null!=n&&(a.where=a.where?`(${a.where}) AND (${n})`:n)}const p=this._getTargetResolution(u.width/l),y=await ut(o);B(n);const d="point"===e.geometryType||y&&y.arcadeUtils.hasGeometryOperations(o);d||(a.maxAllowableOffset=p);let{features:m}=await e.queryFeatures(a,n);const w=d?0:p;m=await ft(e,m,n);for(const t of m)this._featuresResolutions.set(t,w);return m}));return(await Promise.allSettled(o)).reduce(((t,e)=>"fulfilled"===e.status?[...t,...e.value]:t),[]).filter(S)}};function lt(t,e,n){const i=[];if(!t)return i;const r=t=>{const s=0===t.minScale||e<=t.minScale,o=0===t.maxScale||e>=t.maxScale;if(t.visible&&s&&o)if(t.sublayers)t.sublayers.forEach(r);else if(t.popupEnabled){const e=_(t,{...n,defaultPopupTemplateEnabled:!1});null!=e&&i.unshift({sublayer:t,popupTemplate:e})}};return t.map(r),i}function ut(t){return t.expressionInfos?.length||Array.isArray(t.content)&&t.content.some((t=>"expression"===t.type))?T():Promise.resolve()}async function ct(t,e){if(t.capabilities?.operations?.supportsQuery)return!0;try{return await Promise.any(e.map((({sublayer:t})=>t.load().then((()=>t.capabilities.operations.supportsQuery)))))}catch{return!1}}async function ft(t,e,n){const i=t.renderer;return i&&"defaultSymbol"in i&&!i.defaultSymbol&&(e=i.valueExpression?await Promise.all(e.map((t=>i.getSymbolAsync(t,n).then((e=>e?t:null))))).then((t=>t.filter((t=>null!=t)))):e.filter((t=>null!=i.getSymbol(t)))),e}o([a({constructOnly:!0})],at.prototype,"createFetchPopupFeaturesQueryGeometry",void 0),o([a({constructOnly:!0})],at.prototype,"layerView",void 0),o([a({constructOnly:!0})],at.prototype,"highlightGraphics",void 0),o([a({constructOnly:!0})],at.prototype,"highlightGraphicUpdated",void 0),o([a({constructOnly:!0})],at.prototype,"updatingHandles",void 0),at=o([y("esri.views.layers.support.MapService")],at);function ht(t,e,n,i=new f){let r=0;if("2d"===n.type)r=e*(n.resolution??0);else if("3d"===n.type){const i=n.overlayPixelSizeInMapUnits(t),s=n.basemapSpatialReference;r=null==s||s.equals(n.spatialReference)?e*i:R(s)/R(n.spatialReference)}const s=t.x-r,o=t.y-r,a=t.x+r,l=t.y+r,{spatialReference:u}=n;return i.xmin=Math.min(s,a),i.ymin=Math.min(o,l),i.xmax=Math.max(s,a),i.ymax=Math.max(o,l),i.spatialReference=u,i}new f;export{ot as S,at as U,ht as r};
//# sourceMappingURL=p-53d117d0.js.map