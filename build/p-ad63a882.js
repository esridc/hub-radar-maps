import{u as t,m as s,i as r,T as i,c as e,h,l as n,a as u,p as c,b as o,x as f,y as a,o as l,d as p,g as w,j as d,V as m,q as v,A as y,L as g,B as A,O as M,w as b,E as U,F as j,I as F,U as $,M as x,S as B,k as _,v as z,z as D,C as G,D as H,G as I,H as L}from"./p-7020cf1b.js";import{e as O}from"./p-6fe73432.js";import{c4 as V}from"./p-3013819f.js";class k{constructor(t,s){this.layout=t,this.buffer="number"==typeof s?new ArrayBuffer(s*t.stride):s;for(const s of t.fields.keys()){const r=t.fields.get(s);this[s]=new r.constructor(this.buffer,r.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,s){const r=this[t];return r&&r.elementCount===s.ElementCount&&r.elementType===s.ElementType?r:null}slice(t,s){return new k(this.layout,this.buffer.slice(t*this.stride,s*this.stride))}copyFrom(t,s=0,r=0,i=t.count){const e=this.stride;if(e%4==0){const h=new Uint32Array(t.buffer,s*e,i*e/4);new Uint32Array(this.buffer,r*e,i*e/4).set(h)}else{const h=new Uint8Array(t.buffer,s*e,i*e);new Uint8Array(this.buffer,r*e,i*e).set(h)}return this}get usedMemory(){return this.byteLength}dispose(){}}class q{constructor(t=null){this._stride=0,this._lastAligned=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach((t=>this._fields.set(t[0],{...t[1],constructor:N(t[1].constructor)}))))}vec2f(s,r){return this._appendField(s,t,r),this}vec2f64(t,r){return this._appendField(t,s,r),this}vec3f(t,s){return this._appendField(t,r,s),this}vec3f64(t,s){return this._appendField(t,i,s),this}vec4f(t,s){return this._appendField(t,e,s),this}vec4f64(t,s){return this._appendField(t,h,s),this}mat3f(t,s){return this._appendField(t,n,s),this}mat3f64(t,s){return this._appendField(t,u,s),this}mat4f(t,s){return this._appendField(t,c,s),this}mat4f64(t,s){return this._appendField(t,o,s),this}vec4u8(t,s){return this._appendField(t,f,s),this}f32(t,s){return this._appendField(t,a,s),this}f64(t,s){return this._appendField(t,l,s),this}u8(t,s){return this._appendField(t,p,s),this}u16(t,s){return this._appendField(t,w,s),this}i8(t,s){return this._appendField(t,d,s),this}vec2i8(t,s){return this._appendField(t,m,s),this}vec2i16(t,s){return this._appendField(t,v,s),this}vec2u8(t,s){return this._appendField(t,y,s),this}vec4u16(t,s){return this._appendField(t,g,s),this}u32(t,s){return this._appendField(t,A,s),this}_appendField(t,s,r){if(this._fields.has(t))return void V(!1,`${t} already added to vertex buffer layout`);const i=s.ElementCount*O(s.ElementType),e=this._stride;this._stride+=i,this._fields.set(t,{size:i,constructor:s,offset:e,optional:r})}createBuffer(t){return new k(this,t)}createView(t){return new k(this,t)}clone(){const t=new q;return t._stride=this._stride,t._fields=new Map,this._fields.forEach(((s,r)=>t._fields.set(r,s))),t.BufferType=this.BufferType,t}get stride(){if(this._lastAligned!==this._fields.size){let t=1;this._fields.forEach((s=>t=Math.max(t,O(s.constructor.ElementType)))),this._stride=Math.floor((this._stride+t-1)/t)*t,this._lastAligned=this._fields.size}return this._stride}get fields(){return this._fields}}function C(){return new q}class E{constructor(t){this.fields=new Array,t.fields.forEach(((t,s)=>{const r={...t,constructor:K(t.constructor)};this.fields.push([s,r])})),this.stride=t.stride}}const J=[a,t,r,e,n,c,l,s,i,h,u,o,p,y,M,f,w,b,U,g,A,j,F,$,d,m,x,B,_,v,z,D,G,H,I,L];function K(t){return`${t.ElementType}_${t.ElementCount}`}function N(t){return P.get(t)}const P=new Map;J.forEach((t=>P.set(K(t),t)));export{C as H,E as I};
//# sourceMappingURL=p-ad63a882.js.map