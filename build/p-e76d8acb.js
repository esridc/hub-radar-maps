import{d7 as e,d8 as a,d9 as r,aY as t,da as n,cN as s,d0 as o,db as i,cQ as c,a as l,cO as u}from"./p-3013819f.js";import{i as f}from"./p-055b59cb.js";import{$ as y,w as m,I as p,v as d,j as w,y as v,P as b,l as h,d as P,c as $}from"./p-296bc59a.js";import{t as S}from"./p-6e6347a2.js";import{a as I}from"./p-1cc0bf3b.js";import"./p-3b51db5e.js";import"./p-8be499c9.js";import"./p-5f878e96.js";import"./p-897087fa.js";const j="Feature Service",N="feature-layer-utils",O=`${N}-save`,L=`${N}-save-as`,T=`${N}-saveall`,A=`${N}-saveall-as`;function F(e){return{isValid:c(e)&&("feature"!==e.type||!e.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(e){const a=[],r=[];for(const{layer:t,layerJSON:n}of e)t.isTable?r.push(n):a.push(n);return{layers:a,tables:r}}function x(e){return g([e])}async function J(e,a){return/\/\d+\/?$/.test(e.url)?x(a[0]):K(a,e)}async function K(e,a){if(e.reverse(),!a)return g(e);const r=await M(a,e);for(const a of e)z(a.layer,a.layerJSON,r);return D(r,e),r}async function M(e,a){let r=await e.fetchData("json");if(k(r))return r;r||={},C(r);const{layer:{url:t,customParameters:n,apiKey:s}}=a[0];return await Q(r,{url:t??"",customParameters:n,apiKey:s},a.map((e=>e.layer.layerId))),r}function k(e){return!!(e&&Array.isArray(e.layers)&&Array.isArray(e.tables))}function C(e){e.layers||=[],e.tables||=[]}function D(e,a){const r=[],t=[];for(const{layer:e}of a){const{isTable:a,layerId:n}=e;a?t.push(n):r.push(n)}E(e.layers,r),E(e.tables,t)}function E(a,r){if(a.length<2)return;const t=[];for(const{id:e}of a)t.push(e);e(t.sort(G),r.slice().sort(G))&&a.sort(((e,a)=>{const t=r.indexOf(e.id),n=r.indexOf(a.id);return t<n?-1:t>n?1:0}))}function G(e,a){return e<a?-1:e>a?1:0}async function Q(e,a,r){const{url:t,customParameters:n,apiKey:s}=a,{serviceJSON:o,layersJSON:i}=await S(t,{customParameters:n,apiKey:s}),c=R(e.layers,o.layers,r),l=R(e.tables,o.tables,r);e.layers=c.itemResources,e.tables=l.itemResources;const u=[...c.added,...l.added],f=i?[...i.layers,...i.tables]:[];await V(e,u,t,f)}function R(e,r,t){const n=a(e,r,((e,a)=>e.id===a.id));e=e.filter((e=>!n.removed.some((a=>a.id===e.id))));const s=n.added;return s.forEach((({id:a})=>{e.push({id:a})})),{itemResources:e,added:s.filter((({id:e})=>!t.includes(e)))}}async function V(e,a,r,t){const n=await Y(a),s=a.map((({id:e,type:a})=>new(n.get(a))({url:r,layerId:e,sourceJSON:t.find((({id:a})=>a===e))})));await Promise.allSettled(s.map((e=>e.load()))),s.forEach((a=>{const{layerId:r,loaded:t,defaultPopupTemplate:n}=a;if(!t||null==n)return;const s={id:r,popupInfo:n.toJSON()};"ArcGISFeatureLayer"!==a.operationalLayerType&&(s.layerType=a.operationalLayerType),z(a,s,e)}))}async function Y(e){const a=[];e.forEach((({type:e})=>{const r=q(e),t=I[r];a.push(t())}));const r=await Promise.all(a),t=new Map;return e.forEach((({type:e},a)=>{t.set(e,r[a])})),t}function q(e){let a;switch(e){case"Feature Layer":case"Table":a="FeatureLayer";break;case"Oriented Imagery Layer":a="OrientedImageryLayer";break;case"Catalog Layer":a="CatalogLayer"}return a}function z(e,a,r){e.isTable?B(r.tables,a):B(r.layers,a)}function B(e,a){const r=e.findIndex((({id:e})=>e===a.id));-1===r?e.push(a):e[r]=a}function H(e,a){if(!e.length)throw new l(`${a}:missing-parameters`,"'layers' array should contain at least one feature layer")}function U(e,a){const r=e.map((e=>e.portalItem.id));if(new Set(r).size>1)throw new l(`${a}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function W(e,a){const r=e.map((e=>e.layerId));if(new Set(r).size!==r.length)throw new l(`${a}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function X(e){H(e,T),await Promise.all(e.map((e=>e.load())));for(const a of e)h(a,T,F),P({layer:a,itemType:j,errorNamePrefix:T});U(e,T),W(e,T)}async function Z(e,a){const{url:t,layerId:i,title:c,fullExtent:l,isTable:f}=e,y=r(t);a.url="FeatureServer"===y?.serverType?t:`${t}/${i}`,a.title||=c,a.extent=null,f||null==l||(a.extent=await n(l)),s(a,o.METADATA),s(a,o.MULTI_LAYER),u(a,o.SINGLE_LAYER),f&&u(a,o.TABLE)}function _(e,a){for(const t of e){const n=t.parsedUrl.path,s=r(n),o=s?.url.path;if(!o)throw new l(`${a}:invalid-parameters`,$(t,`has unsupported url pattern: ${n}`),{layer:t});const i=s?.serverType;if("FeatureServer"!==i&&"MapServer"!==i)throw new l(`${a}:invalid-parameters`,$(t,`has unsupported server type: ${i}`),{layer:t});if("MapServer"===i&&e.length>1)throw new l(`${a}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=r(e[0].parsedUrl.path),n=t?.url.path,s=e.every((e=>{const a=r(e.parsedUrl.path);return a?.url.path===n}));if(!s)throw new l(`${a}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ee(e){H(e,A),await Promise.all(e.map((e=>e.load())));for(const a of e)h(a,A,F);_(e,A),W(e,A)}async function ae(e,a){let c=0,l=0;for(const{isTable:e}of a)e?l++:c++;const u=a[0].parsedUrl.path,f=r(u);if(e.url="FeatureServer"===f?.serverType?f.url.path:u,e.title||=f.title,e.extent=null,c>0){const r=a.map((e=>e.fullExtent)).filter(t).reduce(((e,a)=>e.clone().union(a)));r&&(e.extent=await n(r))}s(e,o.METADATA),i(e,o.MULTI_LAYER,a.length>1),i(e,o.SINGLE_LAYER,1===a.length),i(e,o.TABLE,l>0&&0===c),d(e)}async function re(e,a){return y({layer:e,itemType:j,validateLayer:F,createItemData:(e,a)=>J(a,[e]),errorNamePrefix:O},a)}async function te(e,a){await X(e);const r=e[0].portalItem,t=m(r),n=await Promise.all(e.map((e=>p(e,t,a)))),s=await J(r,e.map(((e,a)=>({layer:e,layerJSON:n[a]}))));return d(r),await r.update({data:s}),await Promise.all(e.slice(1).map((e=>e.portalItem.reload()))),f(t),r.clone()}async function ne(e,a,r){return w({layer:e,itemType:j,validateLayer:F,createItemData:(e,a)=>Promise.resolve(x(e)),errorNamePrefix:L,newItem:a,setItemProperties:Z},r)}async function se(e,a,r){await ee(e);const t=v({itemType:j,errorNamePrefix:A,newItem:a}),n=m(t),s=await Promise.all(e.map((e=>p(e,n,r)))),o=await K(e.map(((e,a)=>({layer:e,layerJSON:s[a]}))));await ae(t,e),await b(t,o,r);for(const a of e)a.portalItem=t.clone();return f(n),t}export{re as save,te as saveAll,se as saveAllAs,ne as saveAs};
//# sourceMappingURL=p-e76d8acb.js.map