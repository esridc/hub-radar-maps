import{ke as t,e as s,b3 as e,hB as i,X as n}from"./p-3013819f.js";import{E as o,I as r}from"./p-89423226.js";import{o as c,f as h,a,c as l,r as f,h as u,s as d,i as p,g as w,p as m,e as M,_ as y,d as b}from"./p-f1aede5a.js";import{t as g}from"./p-a925664a.js";import{o as x}from"./p-3b8b0ae8.js";import{l as k,m as I,o as _,p as T,n as L,u as A,a as D}from"./p-10e5b6ea.js";import{n as N}from"./p-ad726e47.js";import{a as j,c as P,i as S}from"./p-808395fb.js";import{s as F,e as v}from"./p-7617ea67.js";import{t as B,U as C,O as U,l as O}from"./p-8b546658.js";import{i as R}from"./p-508fdb0a.js";import{C as z}from"./p-3811f238.js";import"./p-3b51db5e.js";import"./p-30a1f911.js";import"./p-b362a32c.js";import"./p-8567e6fe.js";import"./p-89242a33.js";function V(t){return 746===t||747===t||!(t<4352)&&(t>=12704&&t<=12735||(t>=12544&&t<=12591||(t>=65072&&t<=65103&&!(t>=65097&&t<=65103)||(t>=63744&&t<=64255||(t>=13056&&t<=13311||(t>=11904&&t<=12031||(t>=12736&&t<=12783||(t>=12288&&t<=12351&&!(t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||(t>=13312&&t<=19903||(t>=19968&&t<=40959||(t>=12800&&t<=13055||(t>=12592&&t<=12687||(t>=43360&&t<=43391||(t>=55216&&t<=55295||(t>=4352&&t<=4607||(t>=44032&&t<=55215||(t>=12352&&t<=12447||(t>=12272&&t<=12287||(t>=12688&&t<=12703||(t>=12032&&t<=12255||(t>=12784&&t<=12799||(t>=12448&&t<=12543&&12540!==t||(t>=65280&&t<=65519&&!(65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||(t>=65104&&t<=65135&&!(t>=65112&&t<=65118||t>=65123&&t<=65126)||(t>=5120&&t<=5759||(t>=6320&&t<=6399||(t>=65040&&t<=65055||(t>=19904&&t<=19967||(t>=40960&&t<=42127||t>=42128&&t<=42191)))))))))))))))))))))))))))))}function G(t){return!(t<11904)&&(t>=12704&&t<=12735||(t>=12544&&t<=12591||(t>=65072&&t<=65103||(t>=63744&&t<=64255||(t>=13056&&t<=13311||(t>=11904&&t<=12031||(t>=12736&&t<=12783||(t>=12288&&t<=12351||(t>=13312&&t<=19903||(t>=19968&&t<=40959||(t>=12800&&t<=13055||(t>=65280&&t<=65519||(t>=12352&&t<=12447||(t>=12272&&t<=12287||(t>=12032&&t<=12255||(t>=12784&&t<=12799||(t>=12448&&t<=12543||(t>=65040&&t<=65055||(t>=42128&&t<=42191||t>=40960&&t<=42127)))))))))))))))))))}function q(t){switch(t){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function W(t){switch(t){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}const E=24,K=17;class Y{constructor(t,s,e,i,n,o,r){this._glyphItems=t,this._maxWidth=s,this._lineHeight=e,this._letterSpacing=i,this._hAnchor=n,this._vAnchor=o,this._justify=r}getShaping(t,s,e){const i=this._letterSpacing,n=this._lineHeight,o=this._justify,r=this._maxWidth,c=[];let h=0,a=0;for(const s of t){const t=s.codePointAt(0);if(null==t)continue;const n=e&&V(t);let o;for(const s of this._glyphItems)if(o=s[t],o)break;c.push({codePoint:t,x:h,y:a,vertical:n,glyphMosaicItem:o}),o&&(h+=o.metrics.advance+i)}let l=h;if(r>0){l=h/Math.max(1,Math.ceil(h/r))}const f=t.includes("â€‹"),u=[],d=c.length;for(let t=0;t<d-1;t++){const s=c[t].codePoint,e=G(s);if(q(s)||e){let i=0;if(10===s)i-=1e4;else if(e&&f)i+=150;else{40!==s&&65288!==s||(i+=50);const e=c[t+1].codePoint;41!==e&&65289!==e||(i+=50)}u.push(this._buildBreak(t+1,c[t].x,l,u,i,!1))}}const p=this._optimalBreaks(this._buildBreak(d,h,l,u,0,!0));let w=0;const m=s?-n:n;let M=0;for(let t=0;t<p.length;t++){const s=p[t];let e=M;for(;e<s&&W(c[e].codePoint);)c[e].glyphMosaicItem=null,++e;let i=s-1;for(;i>e&&W(c[i].codePoint);)c[i].glyphMosaicItem=null,--i;if(e<=i){const t=c[e].x;for(let s=e;s<=i;s++)c[s].x-=t,c[s].y=a;let s=c[i].x;c[i].glyphMosaicItem&&(s+=c[i].glyphMosaicItem.metrics.advance),w=Math.max(s,w),o&&this._applyJustification(c,e,i)}M=s,a+=m}if(c.length>0){const t=p.length-1,e=(o-this._hAnchor)*w;let i=(-this._vAnchor*(t+1)+.5)*n;s&&t&&(i+=t*n);for(const t of c)t.x+=e,t.y+=i}return c.filter((t=>t.glyphMosaicItem))}static getTextBox(t,s){if(!t.length)return null;let e=1/0,i=1/0,n=0,o=0;for(const r of t){const t=r.glyphMosaicItem.metrics.advance,c=r.x,h=r.y-K,a=c+t,l=h+s;e=Math.min(e,c),n=Math.max(n,a),i=Math.min(i,h),o=Math.max(o,l)}return{x:e,y:i,width:n-e,height:o-i}}static getBox(t){if(!t.length)return null;let s=1/0,e=1/0,i=0,n=0;for(const o of t){const{height:t,left:r,top:c,width:h}=o.glyphMosaicItem.metrics,a=o.x,l=o.y-(t-Math.abs(c)),f=a+h+r,u=l+t;s=Math.min(s,a),i=Math.max(i,f),e=Math.min(e,l),n=Math.max(n,u)}return{x:s,y:e,width:i-s,height:n-e}}static addDecoration(t,s){const e=t.length;if(0===e)return;const i=3;let n=t[0].x+t[0].glyphMosaicItem.metrics.left,o=t[0].y;for(let r=1;r<e;r++){const e=t[r];if(e.y!==o){const c=t[r-1].x+t[r-1].glyphMosaicItem.metrics.left+t[r-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:n,y:o+s-i,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new g(4,0,4,8),metrics:{width:c-n,height:2+2*i,left:0,top:0,advance:0},page:0,code:0}}),o=e.y,n=e.x+e.glyphMosaicItem.metrics.left}}const r=t[e-1].x+t[e-1].glyphMosaicItem.metrics.left+t[e-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:n,y:o+s-i,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new g(4,0,4,8),metrics:{width:r-n,height:2+2*i,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(t,s,e,i){const n=(t-s)*(t-s);return i?t<s?n/2:2*n:n+Math.abs(e)*e}_buildBreak(t,s,e,i,n,o){let r=null,c=this._breakScore(s,e,n,o);for(const t of i){const i=s-t.x,h=this._breakScore(i,e,n,o)+t.score;h<=c&&(r=t,c=h)}return{index:t,x:s,score:c,previousBreak:r}}_optimalBreaks(t){return t?this._optimalBreaks(t.previousBreak).concat(t.index):[]}_applyJustification(t,s,e){const i=t[e],n=i.vertical?E:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0,o=(i.x+n)*this._justify;for(let i=s;i<=e;i++)t[i].x-=o}}const H=4096,J=8,X=.5,Z=2;class Q{constructor(t,s,e=0,i=-1,n=X){this.x=t,this.y=s,this.angle=e,this.segment=i,this.minzoom=n}}class ${constructor(t,s,e,i,n,o=X,r=f){this.anchor=t,this.labelAngle=s,this.glyphAngle=e,this.page=i,this.alternateVerticalGlyph=n,this.minzoom=o,this.maxzoom=r}}class tt{constructor(t,s,e,i,n,o,r,c,h,a,l,f){this.tl=t,this.tr=s,this.bl=e,this.br=i,this.mosaicRect=n,this.labelAngle=o,this.minAngle=r,this.maxAngle=c,this.anchor=h,this.minzoom=a,this.maxzoom=l,this.page=f}}class st{constructor(t){this.shapes=t}}class et{getIconPlacement(t,s,e){const i=new u(t.x,t.y),n=e.rotationAlignment===k.MAP,o=e.keepUpright;let r=e.rotate*d;n&&(r+=t.angle);const h=new st([]);return e.allowOverlap&&e.ignorePlacement||!x||(h.iconColliders=[]),this._addIconPlacement(h,i,s,e,r),n&&o&&this._addIconPlacement(h,i,s,e,r+c),h}_addIconPlacement(t,s,e,i,n){const o=e.rasterizationScale,r=e.width/o,c=e.height/o,h=i.offset;let a=h[0],l=h[1];switch(i.anchor){case I.CENTER:a-=r/2,l-=c/2;break;case I.LEFT:l-=c/2;break;case I.RIGHT:a-=r,l-=c/2;break;case I.TOP:a-=r/2;break;case I.BOTTOM:a-=r/2,l-=c;break;case I.TOP_LEFT:break;case I.BOTTOM_LEFT:l-=c;break;case I.TOP_RIGHT:a-=r;break;case I.BOTTOM_RIGHT:a-=r,l-=c}const d=e.rect,p=2/o,w=a-p,m=l-p,M=w+d.width/o,y=m+d.height/o,b=new u(w,m),g=new u(M,y),k=new u(w,y),_=new u(M,m);if(0!==n){const t=Math.cos(n),s=Math.sin(n);b.rotate(t,s),g.rotate(t,s),k.rotate(t,s),_.rotate(t,s)}const T=new tt(b,_,k,g,d,n,0,256,s,X,f,0);if(t.shapes.push(T),(!i.allowOverlap||!i.ignorePlacement)&&x){const e=i.size,o=i.padding,h={xTile:s.x,yTile:s.y,dxPixels:a*e-o,dyPixels:l*e-o,hard:!i.optional,partIndex:0,width:r*e+2*o,height:c*e+2*o,angle:n,minLod:X,maxLod:f};t.iconColliders.push(h)}}getTextPlacement(t,s,e,i){const n=new u(t.x,t.y),o=i.rotate*d,r=i.rotationAlignment===k.MAP,h=i.keepUpright,a=i.padding;let l=X;const p=!r?0:t.angle,w=t.segment>=0&&r,m=i.allowOverlap&&i.ignorePlacement?null:[],M=[],y=4,b=!w;let g=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY,_=g,T=x;const L=(w||r)&&h,A=i.size/E;let D=!1;for(const t of s)if(t.vertical){D=!0;break}let N,j=0,P=0;if(!w&&D){const t=Y.getTextBox(s,i.lineHeight*E);switch(i.anchor){case I.LEFT:j=t.height/2,P=-t.width/2;break;case I.RIGHT:j=-t.height/2,P=t.width/2;break;case I.TOP:j=t.height/2,P=t.width/2;break;case I.BOTTOM:j=-t.height/2,P=-t.width/2;break;case I.TOP_LEFT:j=t.height;break;case I.BOTTOM_LEFT:P=-t.width;break;case I.TOP_RIGHT:P=t.width;break;case I.BOTTOM_RIGHT:j=-t.height}}j+=i.offset[0]*E,P+=i.offset[1]*E;for(const d of s){const s=d.glyphMosaicItem;if(!s||s.rect.isEmpty)continue;const k=s.rect,I=s.metrics,S=s.page;if(m&&b){if(void 0!==N&&N!==d.y){let s,e,n,r;D?(s=-T+j,e=g+P,n=T-_,r=x-g):(s=g+j,e=_+P,n=x-g,r=T-_);const c={xTile:t.x,yTile:t.y,dxPixels:s*A-a,dyPixels:e*A-a,hard:!i.optional,partIndex:1,width:n*A+2*a,height:r*A+2*a,angle:o,minLod:X,maxLod:f};m.push(c),g=Number.POSITIVE_INFINITY,x=Number.NEGATIVE_INFINITY,_=g,T=x}N=d.y}const F=[];if(w){const i=.5*s.metrics.width,n=(d.x+I.left-y+i)*A*J;if(l=this._placeGlyph(t,l,n,e,t.segment,1,d.vertical,S,F),h&&(l=this._placeGlyph(t,l,n,e,t.segment,-1,d.vertical,S,F)),l>=Z)break}else F.push(new $(n,p,p,S,!1)),r&&h&&F.push(new $(n,p+c,p+c,S,!1));const v=d.x+I.left,B=d.y-K-I.top,C=v+I.width,U=B+I.height;let O,R,z,V,G,q,W,E;if(!w&&D)if(d.vertical){const t=(v+C)/2-I.height/2,s=(B+U)/2+I.width/2;O=new u(-s-y+j,t-y+P),R=new u(O.x+k.width,O.y+k.height),z=new u(O.x,R.y),V=new u(R.x,O.y)}else O=new u(-B+y+j,v-y+P),R=new u(O.x-k.height,O.y+k.width),z=new u(R.x,O.y),V=new u(O.x,R.y);else O=new u(v-y+j,B-y+P),R=new u(O.x+k.width,O.y+k.height),z=new u(O.x,R.y),V=new u(R.x,O.y);for(const s of F){let e,n,r,c;if(s.alternateVerticalGlyph){if(!G){const t=(B+U)/2+P;G=new u((v+C)/2+j-I.height/2-y,t+I.width/2+y),q=new u(G.x+k.height,G.y-k.width),W=new u(q.x,G.y),E=new u(G.x,q.y)}e=G,n=W,r=E,c=q}else e=O,n=z,r=V,c=R;const h=B,l=U,f=s.glyphAngle+o;if(0!==f){const t=Math.cos(f),s=Math.sin(f);e=e.clone(),n=n?.clone(),r=r?.clone(),c=c?.clone(),e.rotate(t,s),c?.rotate(t,s),n?.rotate(t,s),r?.rotate(t,s)}let p=0,N=256;if(w&&D?d.vertical?s.alternateVerticalGlyph?(p=32,N=96):(p=224,N=32):(p=224,N=96):(p=192,N=64),M.push(new tt(e,r,n,c,k,s.labelAngle,p,N,s.anchor,s.minzoom,s.maxzoom,s.page)),m&&(!L||this._legible(s.labelAngle)))if(b)v<g&&(g=v),h<_&&(_=h),C>x&&(x=C),l>T&&(T=l);else if(s.minzoom<Z){const e={xTile:t.x,yTile:t.y,dxPixels:(v+j)*A-a,dyPixels:(h+j)*A-a,hard:!i.optional,partIndex:1,width:(C-v)*A+2*a,height:(l-h)*A+2*a,angle:f,minLod:s.minzoom,maxLod:s.maxzoom};m.push(e)}}}if(l>=Z)return null;if(m&&b){let s,e,n,r;D?(s=-T+j,e=g+P,n=T-_,r=x-g):(s=g+j,e=_+P,n=x-g,r=T-_);const c={xTile:t.x,yTile:t.y,dxPixels:s*A-a,dyPixels:e*A-a,hard:!i.optional,partIndex:1,width:n*A+2*a,height:r*A+2*a,angle:o,minLod:X,maxLod:f};m.push(c)}const S=new st(M);return m&&m.length>0&&(S.textColliders=m),S}_legible(t){const s=h(t);return s<65||s>=193}_placeGlyph(t,s,e,i,n,o,r,h,d){let p=o;const w=p<0?a(t.angle+c,l):t.angle;let m=0;e<0&&(p*=-1,e*=-1,m=c),p>0&&++n;let M=new u(t.x,t.y),y=i[n],b=f;if(i.length<=n)return b;for(;;){const t=y.x-M.x,o=y.y-M.y,c=Math.sqrt(t*t+o*o),f=Math.max(e/c,s),u=t/c,g=o/c,x=a(Math.atan2(g,u)+m,l);if(d.push(new $(M,w,x,h,!1,f,b)),r&&d.push(new $(M,w,x,h,!0,f,b)),f<=s)return f;M=y.clone();do{if(n+=p,i.length<=n||n<0)return f;y=i[n]}while(M.isEqual(y));let k=y.x-M.x,I=y.y-M.y;const _=Math.sqrt(k*k+I*I);k*=c/_,I*=c/_,M.x-=k,M.y-=I,b=f}}}class it extends B{constructor(){super(12)}add(t,s,e){const i=this.array;i.push(t),i.push(s),i.push(e)}}class nt extends B{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,h,a,l,f){const u=this.array;let d=B.i1616to32(t,s);u.push(d);const p=31;d=B.i8888to32(Math.round(p*e),Math.round(p*i),Math.round(p*n),Math.round(p*o)),u.push(d),d=B.i8888to32(Math.round(p*r),Math.round(p*c),Math.round(p*h),Math.round(p*a)),u.push(d),d=B.i1616to32(l,0),u.push(d),f&&u.push(...f)}}class ot extends B{constructor(t){super(t)}add(t,s,e){const i=this.array;i.push(B.i1616to32(t,s)),e&&i.push(...e)}}class rt extends B{constructor(t){super(t)}add(t,s,e,i,n,o,r){const c=this.array,h=this.index;let a=B.i1616to32(t,s);c.push(a);const l=15;return a=B.i8888to32(Math.round(l*e),Math.round(l*i),n,o),c.push(a),r&&c.push(...r),h}}class ct extends B{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,a,l,f,u){const d=this.array;let p=B.i1616to32(t,s);d.push(p),p=B.i1616to32(Math.round(8*e),Math.round(8*i)),d.push(p),p=B.i8888to32(n/4,o/4,c,a),d.push(p),p=B.i8888to32(0,h(r),10*l,Math.min(10*f,255)),d.push(p),u&&d.push(...u)}}class ht extends B{constructor(t){super(t)}add(t,s,e,i,n){const o=this.array,r=B.i1616to32(2*t+e,2*s+i);o.push(r),n&&o.push(...n)}}class at{constructor(t,s,e){this.layerExtent=4096,this._features=[],this.layer=t,this.zoom=s,this._spriteInfo=e,this._filter=t.getFeatureFilter()}pushFeature(t){this._filter&&!this._filter.filter(t,this.zoom)||this._features.push(t)}hasFeatures(){return this._features.length>0}getResources(t,s,e){}}class lt extends at{constructor(t,s,e,i,n){super(t,s,e),this.type=o.CIRCLE,this._circleVertexBuffer=i,this._circleIndexBuffer=n}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(t){const s=this._circleVertexBuffer,e=this._circleIndexBuffer;this._circleIndexStart=3*e.index,this._circleIndexCount=0;const i=this.layer,n=this.zoom;t&&t.setExtent(this.layerExtent);for(const o of this._features){const r=o.getGeometry(t);if(!r)continue;const c=i.circleMaterial.encodeAttributes(o,n,i);for(const t of r)if(t)for(const i of t){const t=s.index;s.add(i.x,i.y,0,0,c),s.add(i.x,i.y,0,1,c),s.add(i.x,i.y,1,0,c),s.add(i.x,i.y,1,1,c),e.add(t,t+1,t+2),e.add(t+1,t+2,t+3),this._circleIndexCount+=6}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this._circleVertexBuffer.array.length,t+=this._circleIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._circleIndexStart,s[i++]=this._circleIndexCount,s[i++]=this._circleVertexBuffer.array.length;for(let t=0;t<this._circleVertexBuffer.array.length;t++)e[i++]=this._circleVertexBuffer.array[t];s[i++]=this._circleIndexBuffer.array.length;for(let t=0;t<this._circleIndexBuffer.array.length;t++)s[i++]=this._circleIndexBuffer.array[t];return s.buffer}}class ft extends at{constructor(t,s,e,i,n,r,c){super(t,s,e),this.type=o.FILL,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=n,this._outlineVertexBuffer=r,this._outlineIndexBuffer=c}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(t,s,e){const i=this.layer,n=this.zoom,o=i.getPaintProperty("fill-pattern");if(o)if(o.isDataDriven)for(const t of this._features)s(o.getValue(n,t),!0);else s(o.getValue(n),!0)}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const s=this.layer,e=this.zoom,{fillMaterial:i,outlineMaterial:n,hasDataDrivenFill:o,hasDataDrivenOutline:r}=s;t&&t.setExtent(this.layerExtent);const c=s.getPaintProperty("fill-pattern"),h=c?.isDataDriven;let a=!c&&s.getPaintValue("fill-antialias",e);if(s.outlineUsesFillColor){if(a&&!s.hasDataDrivenOpacity){const t=s.getPaintValue("fill-opacity",e),i=s.getPaintValue("fill-opacity",e+1);t<1&&i<1&&(a=!1)}if(a&&!s.hasDataDrivenColor){const t=s.getPaintValue("fill-color",e),i=s.getPaintValue("fill-color",e+1);t[3]<1&&i[3]<1&&(a=!1)}}const l=this._features,f=t?.validateTessellation;if(h){const o=[];for(const h of l){const l=c.getValue(e,h),u=this._spriteInfo[l];if(!u?.rect)continue;const d=i.encodeAttributes(h,e,s,u),p=a&&r?n.encodeAttributes(h,e,s):[],w=h.getGeometry(t);o.push({ddFillAttributes:d,ddOutlineAttributes:p,page:u.page,geometry:w}),o.sort(((t,s)=>t.page-s.page));for(const{ddFillAttributes:t,ddOutlineAttributes:e,page:i,geometry:n}of o)this._processFeature(n,a,s.outlineUsesFillColor,t,e,f,i)}}else for(const c of l){const h=o?i.encodeAttributes(c,e,s):null,l=a&&r?n.encodeAttributes(c,e,s):null,u=c.getGeometry(t);this._processFeature(u,a,s.outlineUsesFillColor,h,l,f)}}serialize(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._fillIndexStart,s[i++]=this._fillIndexCount,s[i++]=this._outlineIndexStart,s[i++]=this._outlineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this._fillVertexBuffer.array.length;for(let t=0;t<this._fillVertexBuffer.array.length;t++)e[i++]=this._fillVertexBuffer.array[t];s[i++]=this._fillIndexBuffer.array.length;for(let t=0;t<this._fillIndexBuffer.array.length;t++)s[i++]=this._fillIndexBuffer.array[t];s[i++]=this._outlineVertexBuffer.array.length;for(let t=0;t<this._outlineVertexBuffer.array.length;t++)e[i++]=this._outlineVertexBuffer.array[t];s[i++]=this._outlineIndexBuffer.array.length;for(let t=0;t<this._outlineIndexBuffer.array.length;t++)s[i++]=this._outlineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e,i,n,o,r){if(!t)return;const c=t.length,h=!n||0===n.length;if(s&&(!e||h))for(let s=0;s<c;s++)this._processOutline(t[s],n);const a=32;let l;for(let s=0;s<c;s++){const e=ft._area(t[s]);e>a?(void 0!==l&&this._processFill(t,l,i,o,r),l=[s]):e<-a&&void 0!==l&&l.push(s)}void 0!==l&&this._processFill(t,l,i,o,r)}_processOutline(t,s){const e=this._outlineVertexBuffer,i=this._outlineIndexBuffer,n=i.index;let o,r,c;const h=new u(0,0),a=new u(0,0),l=new u(0,0);let f=-1,d=-1,p=-1,w=-1,m=-1,M=!1;const y=0;let b=t.length;if(b<2)return;const g=t[y];let x=t[b-1];for(;b&&x.isEqual(g);)--b,x=t[b-1];if(!(b-y<2)){for(let n=y;n<b;++n){n===y?(o=t[b-1],r=t[y],c=t[y+1],h.assignSub(r,o),h.normalize(),h.rightPerpendicular()):(o=r,r=c,c=n!==b-1?t[n+1]:t[y],h.assign(a));const u=this._isClipEdge(o,r);-1===w&&(M=u),a.assignSub(c,r),a.normalize(),a.rightPerpendicular();const g=h.x*a.y-h.y*a.x;l.assignAdd(h,a),l.normalize();const x=-l.x*-h.x+-l.y*-h.y;let k=Math.abs(0!==x?1/x:1);k>8&&(k=8),g>=0?(p=e.add(r.x,r.y,h.x,h.y,0,1,s),-1===w&&(w=p),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),d=e.add(r.x,r.y,k*-l.x,k*-l.y,0,-1,s),-1===m&&(m=d),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),f=d,d=p,p=e.add(r.x,r.y,l.x,l.y,0,1,s),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),d=e.add(r.x,r.y,a.x,a.y,0,1,s),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p)):(p=e.add(r.x,r.y,k*l.x,k*l.y,0,1,s),-1===w&&(w=p),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),d=e.add(r.x,r.y,-h.x,-h.y,0,-1,s),-1===m&&(m=d),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),f=d,d=p,p=e.add(r.x,r.y,-l.x,-l.y,0,-1,s),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p),f=e.add(r.x,r.y,-a.x,-a.y,0,-1,s),f>=0&&d>=0&&p>=0&&!u&&i.add(f,d,p))}f>=0&&d>=0&&w>=0&&!M&&i.add(f,d,w),f>=0&&w>=0&&m>=0&&!M&&i.add(f,m,w),this._outlineIndexCount+=3*(i.index-n)}}_processFill(s,e,i,n,o){n=!0;let r;e.length>1&&(r=[]);let c=0;for(const t of e)0!==c&&r.push(c),c+=s[t].length;const h=2*c,a=t.acquire();for(const t of e){const e=s[t],i=e.length;for(let t=0;t<i;++t)a.push(e[t].x,e[t].y)}const l=R(a,r,2);if(n&&R.deviation(a,r,2,l)>0){const t=e.map((t=>s[t].length)),{buffer:n,vertexCount:r}=j(a,t);if(r>0){const t=this._fillVertexBuffer.index;for(let t=0;t<r;t++)this._fillVertexBuffer.add(n[2*t],n[2*t+1],i);for(let s=0;s<r;s+=3){const e=t+s;this._fillIndexBuffer.add(e,e+1,e+2)}if(void 0!==o){const t=this._patternMap,s=t.get(o);s?s[1]+=r:t.set(o,[this._fillIndexStart+this._fillIndexCount,r])}this._fillIndexCount+=r}}else{const t=l.length;if(t>0){const s=this._fillVertexBuffer.index;let e=0;for(;e<h;)this._fillVertexBuffer.add(a[e++],a[e++],i);let n=0;for(;n<t;)this._fillIndexBuffer.add(s+l[n++],s+l[n++],s+l[n++]);if(void 0!==o){const s=this._patternMap,e=s.get(o);e?e[1]+=t:s.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}t.release(a)}_isClipEdge(t,s){return t.x===s.x?t.x<=-64||t.x>=4160:t.y===s.y&&(t.y<=-64||t.y>=4160)}static _area(t){let s=0;const e=t.length-1;for(let i=0;i<e;i++)s+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);return s+=(t[e].x-t[0].x)*(t[e].y+t[0].y),.5*s}}const ut=65535;class dt extends at{constructor(t,s,e,i,n){super(t,s,e),this.type=o.LINE,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=n,this._lineTessellator=new P(pt(this.tessellationProperties),wt(this.tessellationProperties),t.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(t,s,e){const i=this.layer,n=this.zoom,o=i.getPaintProperty("line-pattern"),r=i.getPaintProperty("line-dasharray"),c=i.getLayoutProperty("line-cap");if(!o&&!r)return;const h=c?.getValue(n)||0,a=c?.isDataDriven,l=o?.isDataDriven,f=r?.isDataDriven;if(l||f)for(const t of this._features)s(l?o.getValue(n,t):this._getDashArrayKey(t,n,i,r,a,c,h));else if(o)s(o.getValue(n));else if(r){const t=r.getValue(n);s(i.getDashKey(t,h))}}processFeatures(t){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const s=this.layer,e=this.zoom,i=this._features,n=this._tessellationOptions,{hasDataDrivenLine:o,lineMaterial:r}=s;t&&t.setExtent(this.layerExtent);const c=s.getPaintProperty("line-pattern"),h=s.getPaintProperty("line-dasharray"),a=c?.isDataDriven,l=h?.isDataDriven;let f;f=s.getLayoutProperty("line-cap");const u=f?.isDataDriven?f:null,d=u?null:s.getLayoutValue("line-cap",e),p=d||0,w=!!u;f=s.getLayoutProperty("line-join");const m=f?.isDataDriven?f:null,M=m?null:s.getLayoutValue("line-join",e);f=s.getLayoutProperty("line-miter-limit");const y=f?.isDataDriven?f:null,b=y?null:s.getLayoutValue("line-miter-limit",e);f=s.getLayoutProperty("line-round-limit");const g=f?.isDataDriven?f:null,x=g?null:s.getLayoutValue("line-round-limit",e);f=s.getPaintProperty("line-width");const k=f?.isDataDriven?f:null,I=k?null:s.getPaintValue("line-width",e);f=s.getPaintProperty("line-offset");const _=f?.isDataDriven?f:null,T=_?null:s.getPaintValue("line-offset",e);if(a||l){const o=[];for(const n of i){const i=a?c.getValue(e,n):this._getDashArrayKey(n,e,s,h,w,u,p),l=this._spriteInfo[i];if(!l?.rect)continue;const f=r.encodeAttributes(n,e,s,l),L=n.getGeometry(t);o.push({ddAttributes:f,page:l.page,cap:u?u.getValue(e,n):d,join:m?m.getValue(e,n):M,miterLimit:y?y.getValue(e,n):b,roundLimit:g?g.getValue(e,n):x,halfWidth:.5*(k?k.getValue(e,n):I),offset:_?_.getValue(e,n):T,geometry:L})}o.sort(((t,s)=>t.page-s.page)),n.textured=!0;for(const{ddAttributes:t,page:s,cap:e,join:i,miterLimit:r,roundLimit:c,halfWidth:h,offset:a,geometry:l}of o)n.capType=e,n.joinType=i,n.miterLimit=r,n.roundLimit=c,n.halfWidth=h,n.offset=a,this._processFeature(l,t,s)}else{if(c){const t=c.getValue(e),s=this._spriteInfo[t];if(!s?.rect)return}n.textured=!(!c&&!h),n.capType=d,n.joinType=M,n.miterLimit=b,n.roundLimit=x,n.halfWidth=.5*I,n.offset=T;for(const c of i){const i=o?r.encodeAttributes(c,e,s):null;u&&(n.capType=u.getValue(e,c)),m&&(n.joinType=m.getValue(e,c)),y&&(n.miterLimit=y.getValue(e,c)),g&&(n.roundLimit=g.getValue(e,c)),k&&(n.halfWidth=.5*k.getValue(e,c)),_&&(n.offset=_.getValue(e,c));const h=c.getGeometry(t);this._processFeature(h,i)}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this.tessellationProperties._lineVertexBuffer.array.length,t+=this.tessellationProperties._lineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._lineIndexStart,s[i++]=this._lineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineVertexBuffer.array.length;t++)e[i++]=this.tessellationProperties._lineVertexBuffer.array[t];s[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineIndexBuffer.array.length;t++)s[i++]=this.tessellationProperties._lineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e){if(!t)return;const i=t.length;for(let n=0;n<i;n++)this._processGeometry(t[n],s,e)}_processGeometry(t,s,e){if(t.length<2)return;const i=.001;let n,o,r=t[0],c=1;for(;c<t.length;)n=t[c].x-r.x,o=t[c].y-r.y,n*n+o*o<i*i?t.splice(c,1):(r=t[c],++c);if(t.length<2)return;const h=this.tessellationProperties._lineIndexBuffer,a=3*h.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=ut,this.tessellationProperties._ddValues=s,this._lineTessellator.tessellate(t,this._tessellationOptions);const l=3*h.index-a;if(void 0!==e){const t=this._patternMap,s=t.get(e);s?s[1]+=l:t.set(e,[a+this._lineIndexCount,l])}this._lineIndexCount+=l}_getDashArrayKey(t,s,e,i,n,o,r){const c=n?o.getValue(s,t):r,h=i.getValue(s,t);return e.getDashKey(h,c)}}const pt=t=>(s,e,i,n,o,r,c,h,a,l,f)=>(t._lineVertexBuffer.add(s,e,c,h,i,n,o,r,a,l,f,t._ddValues),t._lineVertexBuffer.index-1),wt=t=>(s,e,i)=>{t._lineIndexBuffer.add(s,e,i)};const mt=10;function Mt(t,s){return t.iconMosaicItem&&s.iconMosaicItem?t.iconMosaicItem.page===s.iconMosaicItem.page?0:t.iconMosaicItem.page-s.iconMosaicItem.page:t.iconMosaicItem&&!s.iconMosaicItem?1:!t.iconMosaicItem&&s.iconMosaicItem?-1:0}class yt extends at{constructor(t,s,e,i,n,r,c,h,a){super(s,e,a.getSpriteItems()),this.type=o.SYMBOL,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=t,this._iconVertexBuffer=i,this._iconIndexBuffer=n,this._textVertexBuffer=r,this._textIndexBuffer=c,this._placementEngine=h,this._workerTileHandler=a}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(t,e,i){const n=this.layer,o=this.zoom;t&&t.setExtent(this.layerExtent);const r=n.getLayoutProperty("icon-image"),c=n.getLayoutProperty("text-field");let h=n.getLayoutProperty("text-transform"),a=n.getLayoutProperty("text-font");const l=[];let f,u,d,p;r&&!r.isDataDriven&&(f=r.getValue(o)),c&&!c.isDataDriven&&(u=c.getValue(o)),h&&h.isDataDriven||(d=n.getLayoutValue("text-transform",o),h=null),a&&a.isDataDriven||(p=n.getLayoutValue("text-font",o),a=null);for(const w of this._features){const m=w.getGeometry(t);if(!m||0===m.length)continue;let M,y;r&&(M=r.isDataDriven?r.getValue(o,w):this._replaceKeys(f,w.values),M&&e(M));let b=!1;if(c&&(y=c.isDataDriven?c.getValue(o,w):this._replaceKeys(u,w.values),y)){switch(y=y.replaceAll("\\n","\n"),h&&(d=h.getValue(o,w)),d){case _.LOWERCASE:y=y.toLowerCase();break;case _.UPPERCASE:y=y.toUpperCase()}if(yt._bidiEngine.hasBidiChar(y)){let t;t="rtl"===yt._bidiEngine.checkContextual(y)?"IDNNN":"ICNNN",y=yt._bidiEngine.bidiTransform(y,t,"VLYSN"),b=!0}if(y.length>0){a&&(p=a.getValue(o,w));for(const t of p){let s=i[t];s||(s=i[t]=new Set);for(const t of y){const e=t.codePointAt(0);null!=e&&s.add(e)}}}}if(!M&&!y)continue;const g=n.getLayoutValue("symbol-sort-key",o,w),x={feature:w,sprite:M,label:y,rtl:b,geometry:m,hash:(y?s(y):0)^(M?s(M):0),priority:g,textFont:p};l.push(x)}this._symbolFeatures=l}processFeatures(t){t&&t.setExtent(this.layerExtent);const s=this.layer,i=this.zoom,n=s.getLayoutValue("symbol-placement",i),o=n!==L.POINT,r=s.getLayoutValue("symbol-spacing",i)*J,c=s.getLayoutProperty("icon-image"),h=s.getLayoutProperty("text-field"),a=c?new C(s,i,o):null,l=h?new U(s,i,o):null,f=this._workerTileHandler;let u;c&&(u=f.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const w=[];let m=1;l&&l.size&&(m=l.size/E);const M=l?l.maxAngle*d:0,y=l?l.size*J:0;for(const t of this._symbolFeatures){let s;a&&u&&t.sprite&&(s=u[t.sprite],s&&s.sdf&&(this._isIconSDF=!0));let c;!!s&&a.update(i,t.feature);let h=0;const d=t.label;if(d){e(l),l.update(i,t.feature);const s=o&&l.rotationAlignment===k.MAP?l.keepUpright:l.writingMode&&l.writingMode.includes(T.VERTICAL);let n=.5;switch(l.anchor){case I.TOP_LEFT:case I.LEFT:case I.BOTTOM_LEFT:n=0;break;case I.TOP_RIGHT:case I.RIGHT:case I.BOTTOM_RIGHT:n=1}let r=.5;switch(l.anchor){case I.TOP_LEFT:case I.TOP:case I.TOP_RIGHT:r=0;break;case I.BOTTOM_LEFT:case I.BOTTOM:case I.BOTTOM_RIGHT:r=1}let a=.5;switch(l.justify){case A.AUTO:a=n;break;case A.LEFT:a=0;break;case A.RIGHT:a=1}const u=l.letterSpacing*E,p=o?0:l.maxWidth*E,w=l.lineHeight*E,M=t.textFont.map((t=>f.getGlyphItems(t)));if(c=new Y(M,p,w,u,n,r,a).getShaping(d,t.rtl,s),c&&c.length>0){let t=1e30,s=-1e30;for(const e of c)t=Math.min(t,e.x),s=Math.max(s,e.x);h=(s-t+2*E)*m*J}}for(let e of t.geometry){const i=[];if(n===L.LINE){if(c?.length&&l?.size){const t=l.size*J*(2+Math.min(2,4*Math.abs(l.offset[1])));e=yt._smoothVertices(e,t)}yt._pushAnchors(i,e,r,h)}else n===L.LINE_CENTER?yt._pushCenterAnchor(i,e):t.feature.type===p.Polygon?yt._pushCentroid(i,e):i.push(new Q(e[0].x,e[0].y));for(const n of i){if(n.x<0||n.x>H||n.y<0||n.y>H)continue;if(o&&h>0&&l?.rotationAlignment===k.MAP&&!yt._honorsTextMaxAngle(e,n,h,M,y))continue;const i={shaping:c,line:e,iconMosaicItem:s,anchor:n,symbolFeature:t,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};w.push(i),this._processFeature(i,a,l)}}}w.sort(Mt),this._addPlacedGlyphs(),this._symbolInstances=w}serialize(){let t=14;t+=this.layerUIDs.length,t+=3*this.markerPageMap.size,t+=3*this.glyphsPageMap.size,t+=yt._symbolsSerializationLength(this._symbolInstances),t+=this._iconVertexBuffer.array.length,t+=this._iconIndexBuffer.array.length,t+=this._textVertexBuffer.array.length,t+=this._textIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer),i=new Float32Array(s.buffer),[n,o,r]=this._sourceTileKey.split("/");let c=0;s[c++]=this.type,s[c++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[c++]=this.layerUIDs[t];s[c++]=this._isIconSDF?1:0,s[c++]=parseFloat(n),s[c++]=parseFloat(o),s[c++]=parseFloat(r),s[c++]=this.markerPageMap.size;for(const[t,[e,i]]of this.markerPageMap)s[c++]=t,s[c++]=e,s[c++]=i;s[c++]=this.glyphsPageMap.size;for(const[t,[e,i]]of this.glyphsPageMap)s[c++]=t,s[c++]=e,s[c++]=i;s[c++]=this._iconVertexBuffer.index/4,s[c++]=this._textVertexBuffer.index/4,c=yt.serializeSymbols(s,e,i,c,this._symbolInstances),s[c++]=this._iconVertexBuffer.array.length;for(let t=0;t<this._iconVertexBuffer.array.length;t++)e[c++]=this._iconVertexBuffer.array[t];s[c++]=this._iconIndexBuffer.array.length;for(let t=0;t<this._iconIndexBuffer.array.length;t++)s[c++]=this._iconIndexBuffer.array[t];s[c++]=this._textVertexBuffer.array.length;for(let t=0;t<this._textVertexBuffer.array.length;t++)e[c++]=this._textVertexBuffer.array[t];s[c++]=this._textIndexBuffer.array.length;for(let t=0;t<this._textIndexBuffer.array.length;t++)s[c++]=this._textIndexBuffer.array[t];return s.buffer}static _symbolsSerializationLength(t){let s=0;s+=1;for(const e of t||[]){s+=5,s+=1;for(const t of e.textColliders)s+=mt;for(const t of e.iconColliders)s+=mt;s+=1,s+=2*e.textVertexRanges.length,s+=1,s+=2*e.iconVertexRanges.length}return s}static serializeSymbols(t,s,e,i,n){n=n||[],s[i++]=n.length;for(const t of n){s[i++]=t.anchor.x,s[i++]=t.anchor.y,s[i++]=t.symbolFeature.hash,s[i++]=t.symbolFeature.priority,s[i++]=t.symbolFeature.feature.featureIndex,s[i++]=t.textColliders.length+t.iconColliders.length;for(const n of t.textColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;for(const n of t.iconColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;s[i++]=t.textVertexRanges.length;for(const[e,n]of t.textVertexRanges)s[i++]=e,s[i++]=n;s[i++]=t.iconVertexRanges.length;for(const[e,n]of t.iconVertexRanges)s[i++]=e,s[i++]=n}return i}_replaceKeys(t,s){return t.replaceAll(/{([^{}]+)}/g,((t,e)=>e in s?s[e]:""))}_processFeature(t,s,e){const{line:i,iconMosaicItem:n,shaping:o,anchor:r}=t,c=this.zoom,h=this.layer,a=!!n;let l=!0;a&&(l=s?.optional||!n);const f=o&&o.length>0,u=!f||e?.optional;let d,p;if(a&&(d=this._placementEngine.getIconPlacement(r,n,s)),(d||l)&&(f&&(p=this._placementEngine.getTextPlacement(r,o,i,e)),p||u)){if(d&&p||(u||l?u||p?l||d||(p=null):d=null:(d=null,p=null)),p){const s=h.hasDataDrivenText?h.textMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._storePlacedGlyphs(t,p.shapes,c,e.rotationAlignment,s),p.textColliders){t.textColliders=p.textColliders;for(const t of p.textColliders){t.minLod=Math.max(c+w(t.minLod),0),t.maxLod=Math.min(c+w(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}if(d){const e=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._addPlacedIcons(t,d.shapes,c,n.page,s.rotationAlignment===k.VIEWPORT,e),d.iconColliders){t.iconColliders=d.iconColliders;for(const t of d.iconColliders){t.minLod=Math.max(c+w(t.minLod),0),t.maxLod=Math.min(c+w(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}}}_addPlacedIcons(t,s,e,i,n,o){const r=Math.max(e-1,0),c=this._iconVertexBuffer,h=this._iconIndexBuffer,a=this._markerMap;for(const l of s){const s=n?0:Math.max(e+w(l.minzoom),r),f=n?25:Math.min(e+w(l.maxzoom),25);if(f<=s)continue;const u=l.tl,d=l.tr,p=l.bl,m=l.br,M=l.mosaicRect,y=l.labelAngle,b=l.minAngle,g=l.maxAngle,x=l.anchor,k=c.index,I=M.x,_=M.y,T=I+M.width,L=_+M.height,A=c.index;c.add(x.x,x.y,u.x,u.y,I,_,y,b,g,s,f,o),c.add(x.x,x.y,d.x,d.y,T,_,y,b,g,s,f,o),c.add(x.x,x.y,p.x,p.y,I,L,y,b,g,s,f,o),c.add(x.x,x.y,m.x,m.y,T,L,y,b,g,s,f,o),t.iconVertexRanges.length>0&&t.iconVertexRanges[0][0]+t.iconVertexRanges[0][1]===A?t.iconVertexRanges[0][1]+=4:t.iconVertexRanges.push([A,4]),h.add(k,k+1,k+2),h.add(k+1,k+2,k+3),a.has(i)?a.get(i)[1]+=6:a.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const t=this._textVertexBuffer,s=this._textIndexBuffer,e=this._glyphMap;for(const[i,n]of this._glyphBufferDataStorage)for(const o of n){const n=t.index,r=o.symbolInstance,c=o.ddAttributes,h=t.index;t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tl[0],o.tl[1],o.xmin,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tr[0],o.tr[1],o.xmax,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.bl[0],o.bl[1],o.xmin,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.br[0],o.br[1],o.xmax,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),r.textVertexRanges.length>0&&r.textVertexRanges[0][0]+r.textVertexRanges[0][1]===h?r.textVertexRanges[0][1]+=4:r.textVertexRanges.push([h,4]),s.add(n,n+1,n+2),s.add(n+1,n+2,n+3),e.has(i)?e.get(i)[1]+=6:e.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(t,s,e,i,n){const o=Math.max(e-1,0),r=i===k.VIEWPORT;let c,h,a,l,f,u,d,p,m,M,y;for(const i of s){if(c=r?0:Math.max(e+w(i.minzoom),o),h=r?25:Math.min(e+w(i.maxzoom),25),h<=c)continue;a=i.tl,l=i.tr,f=i.bl,u=i.br,d=i.labelAngle,p=i.minAngle,m=i.maxAngle,M=i.anchor,y=i.mosaicRect,this._glyphBufferDataStorage.has(i.page)||this._glyphBufferDataStorage.set(i.page,[]);this._glyphBufferDataStorage.get(i.page).push({glyphAnchor:[M.x,M.y],tl:[a.x,a.y],tr:[l.x,l.y],bl:[f.x,f.y],br:[u.x,u.y],xmin:y.x,ymin:y.y,xmax:y.x+y.width,ymax:y.y+y.height,labelAngle:d,minAngle:p,maxAngle:m,minLod:c,maxLod:h,placementLod:o,symbolInstance:t,ddAttributes:n})}}static _pushAnchors(t,s,e,i){e+=i;let n=0;const o=s.length-1;for(let t=0;t<o;t++)n+=u.distance(s[t],s[t+1]);let r=i||e;if(r*=.5,n<=r)return;const c=r/n;let h=0,a=-(e=n/Math.max(Math.round(n/e),1))/2;const l=s.length-1;for(let i=0;i<l;i++){const n=s[i],o=s[i+1],r=o.x-n.x,l=o.y-n.y,f=Math.sqrt(r*r+l*l);let u;for(;a+e<h+f;){a+=e;const s=(a-h)/f,d=m(n.x,o.x,s),p=m(n.y,o.y,s);void 0===u&&(u=Math.atan2(l,r)),t.push(new Q(d,p,u,i,c))}h+=f}}static _pushCenterAnchor(t,s){let e=0;const i=s.length-1;for(let t=0;t<i;t++)e+=u.distance(s[t],s[t+1]);const n=e/2;let o=0;const r=s.length-1;for(let e=0;e<r;e++){const i=s[e],r=s[e+1],c=r.x-i.x,h=r.y-i.y,a=Math.sqrt(c*c+h*h);if(n<o+a){const s=(n-o)/a,l=m(i.x,r.x,s),f=m(i.y,r.y,s),u=Math.atan2(h,c);return void t.push(new Q(l,f,u,e,0))}o+=a}}static _deviation(t,s,e){const i=(s.x-t.x)*(e.x-s.x)+(s.y-t.y)*(e.y-s.y),n=(s.x-t.x)*(e.y-s.y)-(s.y-t.y)*(e.x-s.x);return Math.atan2(n,i)}static _honorsTextMaxAngle(t,s,e,i,n){let o=0;const r=e/2;let c=new u(s.x,s.y),h=s.segment+1;for(;o>-r;){if(--h,h<0)return!1;o-=u.distance(t[h],c),c=t[h]}o+=u.distance(t[h],t[h+1]);const a=[];let l=0;const f=t.length;for(;o<r;){const s=t[h];let e,r=h;do{if(++r,r===f)return!1;e=t[r]}while(e.isEqual(s));let c,d=r;do{if(++d,d===f)return!1;c=t[d]}while(c.isEqual(e));const p=this._deviation(s,e,c);for(a.push({deviation:p,distToAnchor:o}),l+=p;o-a[0].distToAnchor>n;)l-=a.shift().deviation;if(Math.abs(l)>i)return!1;o+=u.distance(e,c),h=r}return!0}static _smoothVertices(t,s){if(s<=0)return t;let e=t.length;if(e<3)return t;const i=[];let n=0,o=0;i.push(0);for(let s=1;s<e;s++){const e=u.distance(t[s],t[s-1]);e>0&&(n+=e,i.push(n),o++,o!==s&&(t[o]=t[s]))}if(e=o+1,e<3)return t;s=Math.min(s,.2*n);const r=t[0].x,c=t[0].y,h=t[e-1].x,a=t[e-1].y,l=u.sub(t[0],t[1]);l.normalize(),t[0].x+=s*l.x,t[0].y+=s*l.y,l.assignSub(t[e-1],t[e-2]),l.normalize(),t[e-1].x+=s*l.x,t[e-1].y+=s*l.y,i[0]-=s,i[e-1]+=s;const f=[];f.push(new u(r,c));const d=1e-6,p=.5*s;for(let n=1;n<e-1;n++){let o=0,r=0,c=0;for(let e=n-1;e>=0;e--){const h=p+i[e+1]-i[n];if(h<0)break;const a=i[e+1]-i[e],l=i[n]-i[e]<p?1:h/a;if(l<d)break;const f=l*l,u=l*h-.5*f*a,w=l*a/s,m=t[e+1],M=t[e].x-m.x,y=t[e].y-m.y;o+=w/u*(m.x*l*h+.5*f*(h*M-a*m.x)-f*l*a*M/3),r+=w/u*(m.y*l*h+.5*f*(h*y-a*m.y)-f*l*a*y/3),c+=w}for(let h=n+1;h<e;h++){const e=p-i[h-1]+i[n];if(e<0)break;const a=i[h]-i[h-1],l=i[h]-i[n]<p?1:e/a;if(l<d)break;const f=l*l,u=l*e-.5*f*a,w=l*a/s,m=t[h-1],M=t[h].x-m.x,y=t[h].y-m.y;o+=w/u*(m.x*l*e+.5*f*(e*M-a*m.x)-f*l*a*M/3),r+=w/u*(m.y*l*e+.5*f*(e*y-a*m.y)-f*l*a*y/3),c+=w}f.push(new u(o/c,r/c))}return f.push(new u(h,a)),t[0].x=r,t[0].y=c,t[e-1].x=h,t[e-1].y=a,f}static _pushCentroid(t,s){const e=0,i=0,n=4096,o=4096,r=s.length-1;let c=0,h=0,a=0,l=s[0].x,f=s[0].y;l>n&&(l=n),l<e&&(l=e),f>o&&(f=o),f<i&&(f=i);for(let t=1;t<r;t++){let r=s[t].x,u=s[t].y,d=s[t+1].x,p=s[t+1].y;r>n&&(r=n),r<e&&(r=e),u>o&&(u=o),u<i&&(u=i),d>n&&(d=n),d<e&&(d=e),p>o&&(p=o),p<i&&(p=i);const w=(r-l)*(p-f)-(d-l)*(u-f);c+=w*(l+r+d),h+=w*(f+u+p),a+=w}c/=3*a,h/=3*a,isNaN(c)||isNaN(h)||t.push(new Q(c,h))}}yt._bidiEngine=new z;var bt;!function(t){t[t.INITIALIZED=0]="INITIALIZED",t[t.NO_DATA=1]="NO_DATA",t[t.READY=2]="READY",t[t.MODIFIED=3]="MODIFIED",t[t.INVALID=4]="INVALID"}(bt||(bt={}));class gt{constructor(t,s,e,i,n,o){if(this._pbfTiles={},this._tileClippers={},this._client=e,this._tile=s,this._sourceDataMaxLOD=i,o){this._styleLayerUIDs=new Set;for(const t of o)this._styleLayerUIDs.add(t)}this._styleRepository=n,this._layers=this._styleRepository?.layers??[];const[r,c,h]=s.tileKey.split("/").map(parseFloat);this._level=r;const a=b(this._level);for(const s of Object.keys(t)){const e=t[s];this._pbfTiles[s]=new N(new Uint8Array(e.protobuff),new DataView(e.protobuff));if(e.refKey){const[t]=e.refKey.split("/").map(parseFloat),i=r-t;if(i>0){const t=(1<<i)-1,e=c&t,n=h&t;this._tileClippers[s]=new M(i,e,n,8,a)}}this._tileClippers[s]||(this._tileClippers[s]=new y)}}_canParseStyleLayer(t){return!this._styleLayerUIDs||this._styleLayerUIDs.has(t)}async parse(t){const s=S(),e=this._initialize(t),{returnedBuckets:i}=e;this._processLayers(e),this._linkReferences(e),this._filterFeatures(e);const n=[],o=new Set,r=(t,s)=>{o.has(t)||(n.push({name:t,repeat:s}),o.add(t))},c={};for(const t of i)t.getResources(t.tileClipper,r,c);if(this._tile.status===bt.INVALID)return[];const h=this._fetchResources(n,c,t);return Promise.all([...h,s]).then((()=>this._processFeatures(e.returnedBuckets)))}_initialize(t){const s=t?.signal;return{signal:s,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(t){const{sourceNameToTileData:s,zoom:e,layers:i,sourceNameToTileClipper:n,sourceNameToUniqueSourceLayerBuckets:o,sourceNameToUniqueSourceLayers:r,returnedBuckets:c,layerIdToBucket:h,referencerUIDToReferencedId:a}=t,l=this._sourceDataMaxLOD;for(let t=i.length-1;t>=0;t--){const f=i[t];if(e<l){if(f.minzoom&&e<Math.floor(f.minzoom)||f.maxzoom&&e>=f.maxzoom)continue}else if(f.maxzoom&&e>=f.maxzoom)continue;if(f.type===D.BACKGROUND||!this._canParseStyleLayer(f.uid)||!s[f.source]||!n[f.source])continue;const u=s[f.source],d=n[f.source],p=f.sourceLayer,w=u[p];if(w){let t=r[f.source];if(t||(t=r[f.source]=new Set),t.add(f.sourceLayer),f.refLayerId)a.set(f.uid,f.refLayerId);else{const t=this._createBucket(f);if(t){t.layerUIDs=[f.uid],t.layerExtent=w.extent,t.tileClipper=d;let s=o[f.source];s||(s=o[f.source]={});let e=s[p];e||(e=s[p]=[]),e.push(t),c.push(t),h[f.id]=t}}}}}_linkReferences(t){const{layerIdToBucket:s,referencerUIDToReferencedId:e}=t;e.forEach(((t,e)=>{s[t]&&s[t].layerUIDs.push(e)}))}_filterFeatures(t){const{signal:s,sourceNameToTileData:e,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:o}=t,r=10*this._level,c=10*(this._level+1),h=[],a=[];for(const t of Object.keys(o)){o[t].forEach((s=>{h.push(s),a.push(t)}))}for(let t=0;t<h.length;t++){const o=a[t],l=h[t];if(!e[o]||!n[o])continue;const f=e[o][l],u=n[o][l];if(!u||0===u.length)continue;if(i(s))return;let d=0;const p=f.getData();for(;p.nextTag(2);){const t=p.getMessage(),s=new F(t,f,d++);t.release();const e=s.values;if(e){const t=e._minzoom;if(t&&t>=c)continue;const s=e._maxzoom;if(s&&s<=r)continue}for(const t of u)t.pushFeature(s)}}}_fetchResources(t,s,e){const i=[],n=this._tile.getWorkerTileHandler();let o,r;t.length>0&&(o=n.fetchSprites(t,this._client,e),i.push(o));for(const t in s){const o=s[t];o.size>0&&(r=n.fetchGlyphs(this._tile.tileKey,t,o,this._client,e),i.push(r))}return i}_processFeatures(t){const s=t.filter((t=>t.hasFeatures()||this._canParseStyleLayer(t.layer.uid)));for(const t of s)t.processFeatures(t.tileClipper);return s}_parseTileData(t){const s={};for(const e of Object.keys(t)){const i=t[e],n={};for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage(),s=new v(t);t.release(),n[s.name]=s;break}default:i.skip()}s[e]=n}return s}_createBucket(t){switch(t.type){case D.BACKGROUND:return null;case D.FILL:return this._createFillBucket(t);case D.LINE:return this._createLineBucket(t);case D.CIRCLE:return this._createCircleBucket(t);case D.SYMBOL:return this._createSymbolBucket(t)}}_createFillBucket(t){return new ft(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new ot(t.fillMaterial.getStride()),new it,new rt(t.outlineMaterial.getStride()),new it)}_createLineBucket(t){return new dt(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new nt(t.lineMaterial.getStride()),new it)}_createCircleBucket(t){return new lt(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new ht(t.circleMaterial.getStride()),new it)}_createSymbolBucket(t){const s=this._tile;return new yt(s.tileKey,t,this._level,new ct(t.iconMaterial.getStride()),new it,new ct(t.textMaterial.getStride()),new it,s.placementEngine,s.getWorkerTileHandler())}}class xt{constructor(t,s,e,i){this.status=bt.INITIALIZED,this.placementEngine=new et,this.tileKey=t,this.refKeys=s,this._workerTileHandler=e,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=bt.INITIALIZED,this._workerTileHandler=null}async parse(t,s){const e=s?.signal;if(null!=e){const t=()=>{e.removeEventListener("abort",t),this.status=bt.INVALID};e.addEventListener("abort",t)}let i;const o={bucketsWithData:[],emptyBuckets:null};try{i=await this._parse(t,s)}catch(t){if(n(t))throw t;return{result:o,transferList:[]}}this.status=bt.READY;const r=o.bucketsWithData,c=[];for(const t of i)if(t.hasFeatures()){const s=t.serialize();r.push(s)}else c.push(t.layer.uid);const h=[...r];let a=null;return c.length>0&&(a=Uint32Array.from(c),h.push(a.buffer)),o.emptyBuckets=a,{result:o,transferList:h}}setObsolete(){this.status=bt.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(t,s){const e=t.sourceName2DataAndRefKey;if(0===Object.keys(e).length)return[];this.status=bt.MODIFIED;return new gt(e,this,s.client,t.sourceDataMaxLOD,this._styleRepository,t.styleLayerUIDs).parse(s)}}const kt=25;class It{constructor(){this._spriteInfo={},this._glyphInfo={},this._sourceDataMaxLOD=kt}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){return this._styleRepository?.layers??[]}async createTileAndParse(t,s){const{key:e}=t,i={};for(const s of Object.keys(t.sourceName2DataAndRefKey)){const e=t.sourceName2DataAndRefKey[s];i[s]=e.refKey}const o=new xt(e,i,this,this._styleRepository);try{return await o.parse({...t,sourceDataMaxLOD:this._sourceDataMaxLOD},s)}catch(t){if(o.setObsolete(),o.release(),!n(t))throw t;return null}}updateStyle(t){if(!t||0===t.length||!this._styleRepository)return;const s=this._styleRepository;for(const e of t){const t=e.type,i=e.data;switch(t){case r.PAINTER_CHANGED:s.setPaintProperties(i.layer,i.paint);break;case r.LAYOUT_CHANGED:s.setLayoutProperties(i.layer,i.layout);break;case r.LAYER_REMOVED:s.deleteStyleLayer(i.layer);break;case r.LAYER_CHANGED:s.setStyleLayer(i.layer,i.index);break;case r.SPRITES_CHANGED:this._spriteInfo={}}}}setStyle(t){const{style:s,sourceDataMaxLOD:e}=t;this._styleRepository=new O(s),this._sourceDataMaxLOD=e,this._spriteInfo={},this._glyphInfo={}}fetchSprites(t,s,e){const i=[],n=this._spriteInfo;for(const s of t){void 0===n[s.name]&&i.push(s)}return 0===i.length?Promise.resolve():s.invoke("getSprites",i,{signal:e?.signal}).then((t=>{for(const s in t){const e=t[s];n[s]=e}}))}getSpriteItems(){return this._spriteInfo}fetchGlyphs(t,s,e,i,n){const o=[];let r=this._glyphInfo[s];return r?e.forEach((t=>{r[t]||o.push(t)})):(r=this._glyphInfo[s]=[],e.forEach((t=>o.push(t)))),0===o.length?Promise.resolve():i.invoke("getGlyphs",{tileID:t,font:s,codePoints:o},n).then((t=>{for(let s=0;s<t.length;s++)t[s]&&(r[s]=t[s])}))}getGlyphItems(t){return this._glyphInfo[t]}}export default It;
//# sourceMappingURL=p-c1ae48da.js.map